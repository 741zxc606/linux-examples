{"name":"Linux-examples","tagline":"A collection of Linux Persistent Memory Programming Examples","body":"LINUX EXAMPLES for PERSISTENT MEMORY PROGRAMMING\r\n\r\nThis is the top-level README for the linux-examples repository.\r\n\r\nThis repository contains some example programs for using Persistent Memory.\r\n\r\nThe goal is to build up a collection of simple examples to help people\r\nunderstand how Persistent Memory is exposed to applications.  These are\r\nNOT PRODUCTION-QUALITY examples.  They are educational snippets of code\r\nto illustrate some basic concepts.  See the REFERENCES section below for\r\nmore mature frameworks.\r\n\r\nThese examples are built on the Linux Persistent Memory API described in:\r\n\r\n\tLINUX_PMEM_API.txt\r\n\r\n\r\nPERSISTENT MEMORY\r\n\r\nPersistent Memory is an emerging technology providing a new tier between\r\ntraditional storage and volatile memory with attributes from both.  The\r\ntwo main qualities of Persistent Memory are that it appears byte-addressable\r\nto applications (allowing direct load/store access rather than the block-based\r\naccess of traditional storage) and that it is persistent.  The term\r\nPersistent Memory (PM), and the related term Storage Class Memory (SCM),\r\nmay not have formal definitions that everyone agrees on, but these terms\r\nusually refer to memory that an application can access directly, without\r\ndemand-paging blocks in and out of a storage device.  The performance of\r\nPM is typically such that a processor load instruction can reasonably wait\r\nfor data from PM (instead of context switching while a page fault is\r\nserviced).  Therefore technologies like hard disks and NAND Flash are not\r\nconsidered fast enough by themselves.  A PM product built on those\r\ntechnologies would have some additional hardware built in to maintain the\r\nperformance expected by the processor during direct access.\r\n\r\nA number of Non-Volatile Memory (NVM) technologies emerging, like Phase\r\nChange Memory, Memristor, Spin-Toque, and others, may bring us into an\r\nera of very large PM capacities with performance more like DRAM than\r\ntraditional storage.  This is appealing for applications requiring access\r\nto large data sets, without the huge DRAM footprint and non-deterministic\r\naccess times seen when demand-paging is used.  Once you imagine applications\r\nstoring information in PM, you quickly realize the need for a way to name\r\nregions of PM so that applications can re-connect to their data on start-up.\r\nNext, the need for a permission model and an administrative model for\r\nmanaging PM comes up (creating, deleting, backing it up, etc.).  The\r\nindustry direction for exposing PM to applications is for PM regions to\r\nbe exposed via the native file APIs on an OS, or something very similar\r\n(see the SNIA information in the REFERENCES section below).  That's the\r\napproach taken with the examples found here.  An example of a\r\nPersistent-Memory-Aware file system that provides PM via native Linux file\r\nAPIs is PMFS, available at:\r\n\r\n\thttps://github.com/linux-pmfs\r\n\r\nSo when PM is accessed by memory mapping files, how is that different\r\nfrom traditional memory mapped files that have been a feature of many\r\noperating systems for decades?  If one writes a program that memory-maps\r\na normal file using the Linux mmap(2) system call, accesses it with loads\r\nand stores, and makes changes durable using the Linux msync(2) system\r\ncall, will that program work without modification on a PM file?  Yes.\r\nBut with a traditional file system, access to the memory-mapped file is \r\nactually paging data in and out of DRAM; mapping a file and changing\r\na single byte involves a page fault (including a context switch or two),\r\nwhere a 4k block is read from storage into memory and a subsequent write\r\nof that 4k block to make the change durable.  With PM, it is possible to\r\nchange that byte directly from the program, without waiting for page faults\r\nor using any DRAM buffers.  On PM the impact of changing a byte of data\r\nis likely much less than a page (probably more like a cache-line read\r\nso the change can happen in the processor cache, followed by a cache-line\r\nflush to make the change durable).\r\n\r\n\r\nEXAMPLES\r\n\r\nEach example occupies a sub-directory here and the README in each\r\nsub-directory tells you why the example was written.  The README also\r\ndescribed how to run the example and what unit tests are available.  At\r\nthis top level, \"make all\" builds every example, \"make clean\" clears out\r\nintermediate files for all examples, and \"make clobber\" removes anything\r\nthat is recreatable for all examples.\r\n\r\nSince these are for educational use, no attempt has been made to optimize\r\nthem for performance, or even make then run on anything but Linux x86_64\r\n(they were all tested on a 64-bit Debian-based distro running the 3.2 kernel\r\nand gcc 4.7.2 initially).  Most of the examples are not MT-safe (unless\r\nmaking something MT-safe was part of the example).  All the examples are\r\nwritten in C and depend on nothing but libc and the code in this repo.\r\nThis is to keep things simple and illustrate the low-level primitives for\r\nPersistent Memory.  Hopefully over time some higher-level language support\r\nwill become commonplace and we'll add additional examples as they become\r\navailable.  See the TODO section below for some ideas if you're looking to\r\ncontribute.\r\n\r\nAs mentioned in the previous section, calling msync(2) to make stores\r\nto PM durable will work but since PM is directly-accessible, there may\r\nbe more optimal ways available with some PM products.  For the purposes\r\nof these examples, a library, libpmem, has been provided and it includes\r\nthis function which can be used instead of msync:\r\n\r\n\tpmem_persist(addr, len, flags)\r\n\r\nSee libpmem/README for more details on the methods available and the\r\nassumptions each method makes about the platform.\r\n\r\nWhat you'll find here:\r\n\r\n\tLICENSE\t\tThe BSD license under which this code is available.\r\n\r\n\tLINUX_PMEM_API.txt\tThe Linux Persistent Memory API, which is\r\n\t\t\t\tprimarily the decades-old memory-mapped file\r\n\t\t\t\tAPI (part of POSIX) with a few optional\r\n\t\t\t\tthings added to it.\r\n\r\n\tFAQ.txt\t\tFrequently asked questions about Persistent Memory\r\n\t\t\tand about these examples.\r\n\r\n\ttrivial\t\tA simple, self-contained, trivial example.  If you\r\n\t\t\tdon't know how to use mmap(2)/msync(2) or if you need\r\n\t\t\ta reminder how they are used, start here.  It is\r\n\t\t\tonly a small step above just typing \"man mmap\" but\r\n\t\t\tthe example is explained, runnable, and includes\r\n\t\t\ta trivial test you can play with.\r\n\r\n\tbasic\t\tA very basic example.  It can store a few strings\r\n\t\t\tto PM and it can read the strings already stored\r\n\t\t\tthere.  This is the simplest example based on libpmem,\r\n\t\t\tso it is a good place to start to understand how that\r\n\t\t\tlibrary is used.\r\n\r\n\t\t\tSee basic/README for details on how to run & test\r\n\t\t\tthis example, and how to use it with the \"icount\"\r\n\t\t\tfault injection test mechanism.\r\n\r\n\tlibpmem\t\tThis library provides an optional part of the\r\n\t\t\tLinux Persistent Memory API.  It is \"optional\"\r\n\t\t\tbecause it is perfectly possible to use PM without\r\n\t\t\tthis library (as shown by the \"trivial\" example\r\n\t\t\tdescribed above).  But with this library, PM\r\n\t\t\tprogramming is more convenient and some operations\r\n\t\t\tare optimized.  If you're looking for examples of\r\n\t\t\tPM programming, reading this code won't help you --\r\n\t\t\tlook at examples like trivial, basic, and binarytree.\r\n\r\n\tlibpmemalloc\tA simple PM malloc-like library.  If you're\r\n\t\t\tlooking for some basic ideas to get you going\r\n\t\t\tmanaging data structures in PM in a way that keeps\r\n\t\t\tthem consistent across crashes, this might be\r\n\t\t\ta good place to start.  libpmemalloc/README explains\r\n\t\t\thow the malloc-like library is used and tested,\r\n\t\t\tand the file libpmemalloc/design.txt explains the\r\n\t\t\tsimple design that went into making it resilient\r\n\t\t\tagainst crashes.  Don't forget to read about much\r\n\t\t\tmore complete PM memory allocation solutions in the\r\n\t\t\tREFERENCES section below.\r\n\r\n\tbinarytree\tBuilding on the libpmemalloc example, this is a\r\n\t\t\tsmall example of a binary tree used to count the\r\n\t\t\tfrequency of variable length strings.\r\n\r\n\tutil\t\tSome common routines for error reporting and\r\n\t\t\tdebug prints.  These have nothing to do with\r\n\t\t\tPersistent Memory.\r\n\r\n\ticount\t\tRoutines to count instructions and simulate crashes.\r\n\t\t\tThese are used for the fault injection runs where\r\n\t\t\twe run a test, count the instructions executed by\r\n\t\t\tthe code snippet under test, and then re-run the test\r\n\t\t\tagain and again, simulating a crash between every pair\r\n\t\t\tof instructions in the code snippet.  See\r\n\t\t\ticount/README for details or you can see this is\r\n\t\t\taction by running \"make allcounts\" in the basic\r\n\t\t\tsub-directory.\r\n\r\n\r\nCODING CONVENTIONS\r\n\r\nSome of the examples store relative pointers in PM data structures\r\nso that those pointers remain valid even if the PM gets mapped into\r\na different virtual address on subsequent runs (which is almost always\r\nthe case).  There are multiple discussions on how to deal with this in\r\npapers mentioned in REFERENCES below.  For these examples, we take a very\r\nbasic approach, making it the programmer's responsibility to keep track\r\nof which pointers are relative and which are absolute.  In the examples,\r\nyou often see pointers with a trailing underscore, like this:\r\n\r\n\tsp->root_\r\n\r\nthe convention is that the trailing underscore is a reminder to the\r\nprogrammer that you cannot dereference that pointer without first adding\r\nthe \"base\" of the PM to it.  The libpmemalloc example creates a macro\r\nto do this called PMEM().  Compilers like the Microsoft C++ compiler have a\r\nnifty \"based pointer\" mechanism so that the compiler largely takes care of\r\nthis for the programmer.  But gcc has no such feature, so we're forced to\r\ndo it by hand.  At least until languages begin to grow more mature PM\r\nprogramming features.\r\n\r\nAnother small convention is that global variables have their first\r\nletter capitalized.  Beyond that, the code is basically K&R-style.\r\n\r\n\r\nTESTING\r\n\r\nFor many years, file system implementers have carefully designed their\r\ndata structures to recover from unexpected system crashes (power failures,\r\nkernel crashes, hardware failures).  This means designing in enough\r\npersistent information so that recovery after a crash can return the on-disk\r\nformat to a consistent state.  The emergence of Persistent Memory brings\r\nall that logic into application space.  A traditional program might allocate\r\nmemory like this:\r\n\r\n\tstruct node *np;\r\n\r\n\tnp = malloc(sizeof(*np));\r\n\t/* ... fill in *np ... */\r\n\tparent->next = np;\r\n\r\nWith Persistent Memory, using a malloc-style interface as shown above\r\nwould lead to a memory leak of the Persistent Memory between the point\r\nwhen malloc() removes the chunk from the free pool and the point where\r\na persistent pointer is set to point at the newly-allocated memory.  Many\r\nstrategies for handling this issue are available, including logging and\r\nreference counting.  But these algorithms can be difficult to test because\r\nit is difficult to simulate failures at the most vulnerable points in the\r\nalgorithms.\r\n\r\nMost of the examples include test programs.  To validate that PM-resident\r\ndata structures are managed in a way that is resilient to crashes, the\r\nicount code is used.  icount (described more in icount/README) provides a\r\nway to count the instructions executed in a test snippet of code, and then\r\nre-run that code again and again, simulating a crash between every possible\r\npair of instructions in the test snippet.  Run \"make allcounts\" in the\r\nbasic sub-directory for a demo.  Using the icount mechanism can be very,\r\nvery time consuming.\r\n\r\nNote the difference between a \"make allcounts\" run for the basic example\r\nand a \"make allcounts\" run for the tree example.  In the basic example,\r\nthe program just stores to PM and the simulated crashes leave the PM in\r\nrandom states, showing partial strings and other garbage.  Compare that\r\nto the tree example, which uses libpmemalloc to make sure things stay\r\nconsistent across crashes.  In that example, when a tree_insert() is\r\ninterrupted by a crash, the string being inserted either makes it completely\r\ninto the tree or it doesn't.  And in the case where it doesn't, no Persistent\r\nMemory is leaked.  That's because the tree example is built on the atomic\r\nmechanisms in libpmemalloc, and that's the point of these examples.\r\n\r\n\r\nCONTACTS\r\n\r\nIf you'd like to contribute more Persistent Memory programming examples\r\n(and we really hope you will!), please fork this project on github, add\r\nyour example, and send a pull request.\r\n\r\nFor more information, questions or comments, contact:\r\n\r\n\tandy.rudoff@intel.com\r\n\r\n\r\nREFERENCES\r\n\r\nSome very interesting research has been happening in the area of\r\nPersistent Memory and more is emerging.  While the examples provided\r\nhere are meant as introductory and simple, some publications cover\r\nthe topic in much more depth and include complete transaction systems,\r\ncompiler/language enhancements, etc.  Here are some of the most\r\nimportant publications in this space (please send links to more and\r\nI'll include them).\r\n\r\n- A Persistent Memory aware file system for Linux.  Under development at:\r\n\r\n\thttps://github.com/linux-pmfs\r\n\r\n- One of the most impressive bodies of work in this area is Mnemosyne.\r\n  Read the paper:\r\n\r\n\tHaris Volos, Andres Jaan Tack, Michael M. Swift: Mnemosyne:\r\n\tLightweight Persistent Memory, The 16th ACM Conference on\r\n\tArchitectural Support for Programming Languages and Operating\r\n\tSystems (ASPLOS 2011), March 2011, Newport Beach, California.\r\n\r\n  and explore the website, which includes full source and documentation:\r\n\r\n \thttp://research.cs.wisc.edu/sonar/projects/mnemosyne/\r\n\r\n- Another very relevant project is NV-Heaps.  Read the paper:\r\n\r\n\tJ. Coburn, et al.:NV-Heaps: Making Persistent Objects Fast and Safe\r\n\twith Next Generation, Non-Volatile Memories, The 16th ACM Conference\r\n\ton Architectural Support for Programming Languages and Operating\r\n\tSystems (ASPLOS 2011), March 2011, Newport Beach, Ca.\r\n\r\n- The June 2013 issue of USENIX ;login: contains an article that discusses\r\n  the NVM Programming Model, including a discussion of Persistent Memory.\r\n\r\n  \thttps://www.usenix.org/publications/login/june-2013-volume-38-number-3\r\n\r\n- The NVM Programming Technical Work Group (TWG) in SNIA has over 35\r\n  companies working together on NVM programming models, including\r\n  Persistent Memory.  You can read more about the TWG here:\r\n\r\n  \thttp://www.snia.org/tech_activities/work/twgs\r\n\r\n  and see a draft of their specification here:\r\n\r\n  \thttp://www.snia.org/tech_activities/publicreview\r\n\r\n- Viking Technology has an excellent FAQ on their NVDIMMs, providing an\r\n  excellent overview of the platform requirements including a description\r\n  of the ADR feature assumed by some of these example programs:\r\n\r\n\thttp://www.vikingtechnology.com/nvdimm-faq\r\n\r\n- The basics of NVDIMM at Wikipedia, with lots of additional links:\r\n\r\n\thttp://en.wikipedia.org/wiki/NVDIMM\r\n\r\nTODO\r\n\r\nHere are some ideas of examples we'd like to add to this collection next:\r\n\r\n- A transaction-based example, using an undo or redo log for consistency\r\n- An example using many files, perhaps with pointers between them\r\n- MT-safe versions of some the examples\r\n- Shared memory examples (multi-process sharing in addition to multi-thread)\r\n- An example of a Persistent cache built on PM\r\n- Bindings for other languages like Java, Python, etc.\r\n- Abstractions that fit into other languages (like Java Persistence API)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}